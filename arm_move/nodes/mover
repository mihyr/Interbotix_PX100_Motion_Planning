#!/usr/bin/env python
"""

**Info**: This *mover* node publishes 

**Publishers**:
    visualization_marker - publish marker of different shape and color based on their current location
                            (shape and color changes when x coordinate sign alters. Color change is set to random)

**Subscriber:
    point - Subscribe to points topic (x,y coordinate data) published by arm_traj node

**Parameters**:
    total_time = Time required to complete one loop of trajectory
    Pub_Frequency - ROS Publishing freq Rate
    
**Note**:

"""

from rosparam import dump_params
import rospy
import sys
import copy
import moveit_commander
import moveit_msgs.msg
import geometry_msgs.msg
from geometry_msgs.msg import Quaternion, Vector3
from moveit_msgs.msg import MoveItErrorCodes
from math import pi, dist, fabs, cos
from std_msgs.msg import String
from moveit_commander.conversions import pose_to_list
from std_srvs.srv import Empty, EmptyResponse
from arm_move.srv import reset, step, follow, stepRequest, stepResponse

#Define frequency rate
freq = rospy.get_param("/Fr")
x_waypoints = rospy.get_param("/x_waypoints")
z_waypoints = rospy.get_param("/z_waypoints")
gripper_state = rospy.get_param("/gripper_state")

#sdump_params('$(find arm_move)/generated_waypoints.yaml', '/px100/waypoints')

def main():
        
    #initialize moveit_commander
    moveit_commander.roscpp_initialize(sys.argv)

    #initialize node
    rospy.init_node('mover')

    #instantiate a RobotCommander object
    robot = moveit_commander.RobotCommander()

    #instantiate a PlanningSceneInterface object
    scene = moveit_commander.PlanningSceneInterface()

    group_name = "interbotix_arm"
    move_group = moveit_commander.MoveGroupCommander(group_name)
    gripper_name = "interbotix_gripper"
    gripper_group = moveit_commander.MoveGroupCommander(gripper_name)

    #logerr msg to check if node is running
    rospy.logerr("This is just a check for mover node, ignore me")
    
    #define ros frequency
    hz = rospy.Rate(freq)


    #Define pause_callback and resume_callback for pause and resume services
    def reset_callback(msg):
        global x_waypoints, z_waypoints, gripper_state
        #add realsense_box
        box_pose = geometry_msgs.msg.PoseStamped()
        box_pose.header.frame_id = "world"
        #box_pose.pose.position = Vector3(0.2,0,0.01)
        #box_pose.pose.orientation = Quaternion(0,0,1,1)
        box_pose.pose.position = msg.box_position
        box_pose.pose.orientation = msg.box_orientation
        box_name = "realsense_box"
        scene.add_box(box_name, box_pose, size=(0.14, 0.09, 0.05))

        #move robot to pre-defined "Home" position
        move_group.set_named_target(msg.Goal_Pose)
        move_group.go()
        move_group.stop()
        move_group.clear_pose_targets()

        #clear waypoints
        if msg.clear_waypoints ==True:
            x_waypoints = []
            z_waypoints = []
            gripper_state = []
            return {'response': "Home Position Set, waypoints cleared"}
        else:
            return {'response': "Home Position Set, waypoints not cleared"}

    def step_callback(msg):
        global x_waypoints, z_waypoints, gripper_state

        pose_goal = geometry_msgs.msg.Pose()
        pose_goal.position = msg.goal_position
        pose_goal.orientation = msg.goal_orientation
        move_group.set_pose_target(pose_goal)
        (success_status, trajectory_message, planning_time, error) = move_group.plan()

        move_group.execute(trajectory_message, wait=True)
        move_group.go()
        move_group.stop()
        move_group.clear_pose_targets()
        #print(error)

        gripper_group.set_named_target(msg.Gripper_state)
        gripper_group.go()
        gripper_group.stop()
        gripper_group.clear_pose_targets()

        if success_status == 1 and msg.record==True:
            x_waypoints.append(pose_goal.position.x)
            z_waypoints.append(pose_goal.position.z)
            gripper_state.append(msg.Gripper_state)
            rospy.set_param('x_waypoints', x_waypoints)
            rospy.set_param('z_waypoints', z_waypoints)
            rospy.set_param('gripper_state', gripper_state)
        

        return {'response': str(planning_time), 'error':error }

    def follow_callback(msg):
        global x_waypoints, z_waypoints, gripper_state
        rospy.wait_for_service('step')
        step_service = rospy.ServiceProxy('step', step)
        for j in range(msg.repeat+1 ):
            for i in range(len(x_waypoints)):
                Step_input = stepRequest()
                Step_input.goal_position = Vector3(x_waypoints[i],0,z_waypoints[i])
                Step_input.Gripper_state = gripper_state[i]
                Step_input.goal_orientation = Quaternion(0,0,0,1)
                Step_input.record = False
                rospy.logerr(Step_input)
                step_service(Step_input)
            
        if msg.repeat == 0:
            return {'response': "Completed loop without repeat" }
        else:
            return {'response': f"Completed loop with {msg.repeat} repeats" }

    #init pause and resume services
    reset_srv = rospy.Service("reset", reset, reset_callback)
    step_srv = rospy.Service("step", step, step_callback)
    follow_srv = rospy.Service("follow", follow, follow_callback)

    #iteration loop
    while not rospy.is_shutdown():

        #add table
        box_pose = geometry_msgs.msg.PoseStamped()
        box_pose.header.frame_id = "world"
        box_pose.pose.position = Vector3(0,0,-0.01)
        box_pose.pose.orientation = Quaternion(0,0,0,1)
        box_name = "table"
        scene.add_box(box_name, box_pose, size=(0.75, 0.75, 0.02))

        current_pose = move_group.get_current_pose().pose
  
        rospy.loginfo(x_waypoints)

        #go to sleep!
        hz.sleep()

if __name__ == "__main__":
    try:
        main()
    except rospy.ROSInterruptException:
        pass 
